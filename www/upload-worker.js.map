{"version":3,"file":"upload-worker.js","sources":["../src/libs/bintools.js","../src/libs/msgpack.js","../src/libs/link.js","../src/libs/idb-keyval.js","../src/libs/cas-idb.js","../src/libs/async.js","../src/upload-worker.js"],"sourcesContent":["\nexport function addInspect() {\n  // Make working with Uint8Array less painful in node.js\n  Uint8Array.prototype.inspect = function () {\n    let str = '';\n    for (let i = 0; i < this.length; i++) {\n      if (i >= 50) { str += '...'; break; }\n      str += (this[i] < 0x10 ? ' 0' : ' ') + this[i].toString(16);\n    }\n    return '<Uint8Array' + str + '>';\n  }\n}\n\n// TYPES:\n//   bin - a Uint8Array containing binary data.\n//   str - a normal unicode string.\n//   raw - a string where each character's charCode is a byte value. (utf-8)\n//   hex - a string holding binary data as lowercase hexadecimal.\n//   b64 - a string holding binary data in base64 encoding.\n\n// Convert a raw string into a Uint8Array\nexport function rawToBin(raw, start, end) {\n  raw = '' + raw;\n  start = start == null ? 0 : start | 0;\n  end = end == null ? raw.length : end | 0;\n  let len = end - start;\n  let bin = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bin[i] = raw.charCodeAt(i + start);\n  }\n  return bin;\n}\n\nexport function binToRaw(bin, start, end) {\n  if (!(bin instanceof Uint8Array)) bin = new Uint8Array(bin);\n  start = start == null ? 0 : start | 0;\n  end = end == null ? bin.length : end | 0;\n  let raw = '';\n  for (let i = start || 0; i < end; i++) {\n    raw += String.fromCharCode(bin[i]);\n  }\n  return raw;\n}\n\nexport function binToHex(bin, start, end) {\n  if (!(bin instanceof Uint8Array)) bin = new Uint8Array(bin);\n  start = start == null ? 0 : start | 0;\n  end = end == null ? bin.length : end | 0;\n  let hex = '';\n  for (let i = start; i < end; i++) {\n    let byte = bin[i];\n    hex += (byte < 0x10 ? '0' : '') + byte.toString(16);\n  }\n  return hex;\n}\n\nexport function hexToBin(hex, start, end) {\n  hex = '' + hex;\n  start = start == null ? 0 : start | 0;\n  end = end == null ? hex.length : end | 0;\n  let len = (end - start) >> 1;\n  let bin = new Uint8Array(len);\n  let offset = 0;\n  for (let i = start; i < end; i += 2) {\n    bin[offset++] = parseInt(hex.substr(i, 2), 16);\n  }\n  return bin;\n}\n\nexport function strToRaw(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nexport function rawToStr(raw) {\n  return decodeURIComponent(escape(raw));\n}\n\nfunction getCodes() {\n  return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n}\nlet map;\nfunction getMap() {\n   if (map) return map;\n   map = [];\n   let codes = getCodes();\n   for (let i = 0, l = codes.length; i < l; i++) {\n     map[codes.charCodeAt(i)] = i;\n   }\n   return map;\n}\n\n// Loop over input 3 bytes at a time\n// a,b,c are 3 x 8-bit numbers\n// they are encoded into groups of 4 x 6-bit numbers\n// aaaaaa aabbbb bbbbcc cccccc\n// if there is no c, then pad the 4th with =\n// if there is also no b then pad the 3rd with =\nexport function binToB64(bin) {\n  let b64 = \"\";\n  let codes = getCodes();\n  for (let i = 0, l = bin.length; i < l; i += 3) {\n    let a = bin[i],\n        b = i + 1 < l ? bin[i + 1] : -1,\n        c = i + 2 < l ? bin[i + 2] : -1;\n    b64 +=\n      // Higher 6 bits of a\n      codes[a >> 2] +\n      // Lower 2 bits of a + high 4 bits of b\n      codes[((a & 3) << 4) | (b >= 0 ? b >> 4 : 0)] +\n      // Low 4 bits of b + High 2 bits of c\n      (b >= 0 ? codes[((b & 15) << 2) | (c >= 0 ? c >> 6 : 0)] : \"=\") +\n      // Lower 6 bits of c\n      (c >= 0 ? codes[c & 63] : \"=\");\n  }\n  return b64;\n}\n\n// loop over input 4 characters at a time\n// The characters are mapped to 4 x 6-bit integers a,b,c,d\n// They need to be reassembled into 3 x 8-bit bytes\n// aaaaaabb bbbbcccc ccdddddd\n// if d is padding then there is no 3rd byte\n// if c is padding then there is no 2nd byte\nexport function b64ToBin(b64) {\n  let map = getMap();\n  let bytes = [];\n  let j = 0;\n  for (let i = 0, l = b64.length; i < l; i += 4) {\n    let a = map[b64.charCodeAt(i)];\n    let b = map[b64.charCodeAt(i + 1)];\n    let c = map[b64.charCodeAt(i + 2)];\n    let d = map[b64.charCodeAt(i + 3)];\n\n    // higher 6 bits are the first char\n    // lower 2 bits are upper 2 bits of second char\n    bytes[j] = (a << 2) | (b >> 4);\n\n    // if the third char is not padding, we have a second byte\n    if (c < 64) {\n      // high 4 bits come from lower 4 bits in b\n      // low 4 bits come from high 4 bits in c\n      bytes[j + 1] = ((b & 0xf) << 4) | (c >> 2);\n\n      // if the fourth char is not padding, we have a third byte\n      if (d < 64) {\n        // Upper 2 bits come from Lower 2 bits of c\n        // Lower 6 bits come from d\n        bytes[j + 2] = ((c & 3) << 6) | d;\n      }\n    }\n    j = j + 3;\n  }\n  return new Uint8Array(bytes);\n}\n\nexport function strToBin(str) {\n  return rawToBin(strToRaw(str));\n}\n\nexport function binToStr(bin, start, end) {\n  return rawToStr(binToRaw(bin, start, end));\n}\n\nexport function rawToHex(raw, start, end) {\n  return binToHex(rawToBin(raw, start, end));\n}\n\nexport function hexToRaw(hex) {\n  return binToRaw(hexToBin(hex));\n}\n\nexport function strToHex(str) {\n  return binToHex(strToBin(str));\n}\n\nexport function hexToStr(hex) {\n  return binToStr(hexToBin(hex));\n}\n\nexport function b64ToStr(b64) {\n  return binToStr(b64ToBin(b64));\n}\n\nexport function strToB64(str) {\n  return binToB64(strToBin(str));\n}\n\nexport function b64ToHex(b64) {\n  return binToHex(b64ToBin(b64));\n}\n\nexport function hexToB64(hex) {\n  return binToB64(hexToBin(hex));\n}\n\nexport function b64ToRaw(b64) {\n  return binToRaw(b64ToBin(b64));\n}\n\nexport function rawToB64(raw, start, end) {\n  return binToB64(rawToBin(raw, start, end));\n}\n\n\n// This takes nested lists of numbers, strings and array buffers and returns\n// a single buffer.  Numbers represent single bytes, strings are raw 8-bit\n// strings, and buffers represent themselves.\n// EX:\n//    1           -> <01>\n//    \"Hi\"        -> <48 69>\n//    [1, \"Hi\"]   -> <01 48 69>\n//    [[1],2,[3]] -> <01 02 03>\nexport function flatten(parts) {\n  if (typeof parts === \"number\") return new Uint8Array([parts]);\n  if (parts instanceof Uint8Array) return parts;\n  let buffer = new Uint8Array(count(parts));\n  copy(buffer, 0, parts);\n  return buffer;\n}\n\nfunction count(value) {\n  if (value == null) return 0;\n  if (typeof value === \"number\") return 1;\n  if (typeof value === \"string\") return value.length;\n  if (value instanceof Uint8Array) return value.length;\n  if (!Array.isArray(value)) {\n    throw new TypeError(\"Bad type for flatten: \" + typeof value);\n  }\n  let sum = 0;\n  for (let piece of value) {\n    sum += count(piece);\n  }\n  return sum;\n}\n\nfunction copy(buffer, offset, value) {\n  if (value == null) return offset;\n  if (typeof value === \"number\") {\n    buffer[offset++] = value;\n    return offset;\n  }\n  if (typeof value === \"string\") {\n    for (let i = 0, l = value.length; i < l; i++) {\n      buffer[offset++] = value.charCodeAt(i);\n    }\n    return offset;\n  }\n  if (value instanceof ArrayBuffer) {\n    value = new Uint8Array(value);\n  }\n  for (let piece of value) {\n    offset = copy(buffer, offset, piece);\n  }\n  return offset;\n}\n\n\n// indexOf for arrays/buffers.  Raw is a string in raw encoding.\n// returns -1 when not found.\n// start and end are indexes into buffer.  Default is 0 and length.\nexport function indexOf(bin, raw, start, end) {\n  start = start == null ? 0 : start | 0;\n  end = end == null ? bin.length : end | 0;\n  outer: for (let i = start || 0; i < end; i++) {\n    for (let j = 0, l = raw.length; j < l; j++) {\n      if (i + j >= end || bin[i + j] !== raw.charCodeAt(j)) {\n        continue outer;\n      }\n    }\n    return i;\n  }\n  return -1;\n}\n\nexport function uint8(num) {\n  return (num>>>0) & 0xff;\n}\n\nexport function uint16(num) {\n  num = (num>>>0) & 0xffff;\n  return [\n    num >> 8,\n    num & 0xff\n  ];\n}\nexport function uint32(num) {\n  num >>>= 0;\n  return [\n    num >> 24,\n    (num >> 16) & 0xff,\n    (num >> 8) & 0xff,\n    num & 0xff\n  ];\n}\n\nexport function uint64(value) {\n  if (value < 0) value += 0x10000000000000000;\n  return [\n    uint32(value / 0x100000000),\n    uint32(value % 0x100000000)\n  ];\n}\n","import { flatten, strToBin, binToStr, uint8, uint16, uint32, uint64 } from \"./bintools\"\n\nlet extensions = [];\nlet extdex = {};\n\nexport function register(code, Constructor, encoder, decoder) {\n  extensions.push(extdex[code] = {\n    code: code,\n    Constructor: Constructor,\n    encoder: encoder,\n    decoder: decoder\n  });\n}\n\nexport function encode(value) {\n  return flatten(realEncode(value));\n}\n\nfunction pairMap(key) {\n  return [\n    realEncode(key),\n    realEncode(this[key])\n  ];\n}\n\n\nfunction tooLong(len, value) {\n  throw new TypeError(\"Value is too long: \" + (typeof value) + \"/\" + len);\n}\n\nfunction realEncode(value) {\n  // nil format family\n  if (value == null) return 0xc0;\n\n  // bool format family\n  if (value === false) return 0xc2;\n  if (value === true) return 0xc3\n\n  if (typeof value === \"number\") {\n    // int format family\n    if (Math.floor(value) === value) {\n      // Positive integers\n      if (value >= 0) {\n        if (value < 0x80) return value;\n        if (value < 0x100) return [0xcc, value];\n        if (value < 0x10000) return [0xcd, uint16(value)];\n        if (value < 0x100000000) return [0xce, uint32(value)];\n        if (value < 0x10000000000000000) return [0xcf, uint64(value)];\n        tooLong(value, value);\n      }\n      // Negative integers\n      if (value > -0x20) return value + 0x100;\n      if (value >= -0x80) return [0xd0, uint8(value)];\n      if (value >= -0x8000) return [0xd1, uint16(value)];\n      if (value >= -0x80000000) return [0xd2, uint32(value)];\n      if (value >= -0x8000000000000000) return [0xd3, uint64(value)];\n      tooLong(value, value);\n    }\n\n    // float format family\n    else {\n      // All numbers in JS are double, so just assume that when encoding.\n      let buf = new Uint8Array(8);\n      new DataView(buf).setFloat64(0, value, false);\n      return [0xcb, buf];\n    }\n  }\n\n  // str format family\n  if (value.constructor === String) {\n    value = strToBin(value);\n    let len = value.length;\n    if (len < 0x20) return [0xa0|len, value];\n    if (len < 0x100) return [0xd9, len, value];\n    if (len < 0x10000) return [0xda, uint16(len), value];\n    if (len < 0x100000000) return [0xdb, uint32(len), value];\n    tooLong(len, value);\n  }\n\n  // bin format family\n  if (value.constructor === ArrayBuffer) value = new Uint8Array(value);\n  if (value.constructor === Uint8Array) {\n    let len = value.length;\n    if (len < 0x100) return [0xc4, len, value];\n    if (len < 0x10000) return [0xc5, uint16(len), value];\n    if (len < 0x100000000) return [0xc6, uint32(len), value];\n    tooLong(len, value);\n  }\n\n  // array format family\n  if (Array.isArray(value)) {\n    let len = value.length;\n    if (len < 0x10) return [0x90|len, value.map(realEncode)];\n    if (len < 0x10000) return [0xdc, uint16(len), value.map(realEncode)];\n    if (len < 0x100000000) return [0xdd, uint32(len), value.map(realEncode)];\n    tooLong(len, value);\n  }\n\n  // map format family\n  if (value.constructor === Object) {\n    let keys = Object.keys(value);\n    let len = keys.length;\n    if (len < 0x10) return [0x80|len, keys.map(pairMap, value)];\n    if (len < 0x10000) return [0xde, uint16(len), keys.map(pairMap, value)];\n    if (len < 0x100000000) return [0xdf, uint32(len), keys.map(pairMap, value)];\n    tooLong(len, value);\n  }\n\n  // ext format family\n  for (let ext of extensions) {\n    if (value.constructor === ext.Constructor) {\n      let buf = ext.encoder(value);\n      let len = buf.length;\n      if (len === 1) return [0xd4, ext.code, buf];\n      if (len === 2) return [0xd5, ext.code, buf];\n      if (len === 4) return [0xd6, ext.code, buf];\n      if (len === 8) return [0xd7, ext.code, buf];\n      if (len === 16) return [0xd8, ext.code, buf];\n      if (len < 0x100) return [0xc7, len, ext.code, buf];\n      if (len < 0x10000) return [0xc8, uint16(len), ext.code, buf];\n      if (len < 0x100000000) return [0xc8, uint32(len), ext.code, buf];\n      tooLong(len, value);\n    }\n  }\n\n  throw new TypeError(\n    \"Unknown type: \" + Object.prototype.toString.call(value) +\n    \"\\nPerhaps register it as a custom type?\");\n}\n\nexport function decode(buf) {\n  let offset = 0,\n      buffer = buf;\n  return realDecode();\n\n  function readMap(len) {\n    let obj = {};\n    while (len-- > 0) {\n      obj[realDecode()] = realDecode();\n    }\n    return obj;\n  }\n\n  function readArray(len) {\n    let arr = new Array(len);\n    for (let i = 0; i < len; i++) {\n      arr[i] = realDecode();\n    }\n    return arr;\n  }\n\n  function readString(len) {\n    var str = binToStr(buffer, offset, offset + len);\n    offset += len;\n    return str;\n  }\n\n  function readBin(len) {\n    let buf = buffer.slice(offset, offset + len);\n    offset += len;\n    return buf;\n  }\n\n  function readExt(len, type) {\n    let buf = buffer.slice(offset, offset + len);\n    offset += len;\n    let ext = extdex[type];\n    return ext.decoder(buf);\n  }\n\n  function read8() {\n    return (buffer[offset++]) >>> 0;\n  }\n\n  function read16() {\n    return (\n      buffer[offset++] << 8 |\n      buffer[offset++]\n    ) >>> 0;\n  }\n\n  function read32() {\n    return (\n      buffer[offset++] << 24 |\n      buffer[offset++] << 16 |\n      buffer[offset++] << 8 |\n      buffer[offset++]\n    ) >>> 0;\n  }\n\n  function read64() {\n    return read32() * 0x100000000 +\n           read32();\n  }\n\n  function readFloat() {\n    let num = new DataView(buffer).getFloat32(offset, false);\n    offset += 4;\n    return num;\n  }\n\n  function readDouble() {\n    let num = new DataView(buffer).getFloat64(offset, false);\n    offset += 8;\n    return num;\n  }\n\n  function realDecode() {\n    if (offset >= buffer.length) {\n      throw new Error(\"Unexpected end of msgpack buffer\");\n    }\n    let first = buffer[offset++];\n    // positive fixint\n    if (first < 0x80) return first;\n    // fixmap\n    if (first < 0x90) return readMap(first & 0xf);\n    // fixarray\n    if (first < 0xa0) return readArray(first & 0xf);\n    // fixstr\n    if (first < 0xc0) return readString(first & 0x1f);\n    // negative fixint\n    if (first >= 0xe0) return first - 0x100;\n    switch (first) {\n      // nil\n      case 0xc0: return null;\n      // false\n      case 0xc2: return false;\n      // true\n      case 0xc3: return true;\n      // bin 8\n      case 0xc4: return readBin(read8());\n      // bin 16\n      case 0xc5: return readBin(read16());\n      // bin 32\n      case 0xc6: return readBin(read32());\n      // ext 8\n      case 0xc7: return readExt(read8(), read8());\n      // ext 16\n      case 0xc8: return readExt(read16(), read8());\n      // ext 32\n      case 0xc9: return readExt(read32(), read8());\n      // float 32\n      case 0xca: return readFloat();\n      // float 64\n      case 0xcb: return readDouble();\n      // uint 8\n      case 0xcc: return read8();\n      // uint 16\n      case 0xcd: return read16();\n      // uint 32\n      case 0xce: return read32();\n      // uint 64\n      case 0xcf: return read64();\n      // int 8\n      case 0xd0: return read8() - 0x100;\n      // int 16\n      case 0xd1: return read16() - 0x10000;\n      // int 32\n      case 0xd2: return read32() - 0x100000000;\n      // int 64\n      case 0xd3: return read64() - 0x10000000000000000;\n      // fixext 1\n      case 0xd4: return readExt(1, read8());\n      // fixext 2\n      case 0xd5: return readExt(2, read8());\n      // fixext 4\n      case 0xd6: return readExt(4, read8());\n      // fixext 8\n      case 0xd7: return readExt(8, read8());\n      // fixext 16\n      case 0xd8: return readExt(16, read8());\n      // str 8\n      case 0xd9: return readString(read8());\n      // str 16\n      case 0xda: return readString(read16());\n      // str 32\n      case 0xdb: return readString(read32());\n      // array 16\n      case 0xdc: return readArray(read16());\n      // array 32\n      case 0xdd: return readArray(read32());\n      // map 16\n      case 0xde: return readMap(read16());\n      // map 32\n      case 0xdf: return readMap(read32());\n\n      default: throw new Error(\"Unexpected byte: \" + first.toString(16));\n    }\n  }\n}\n","import { register, encode, decode } from \"./msgpack\";\nimport { sha1 } from \"./sha1\";\nimport { binToHex, hexToBin } from \"./bintools\";\n\n// Consumers of this API must provide the following interface here.\n// function get(hash) -> promise<value>\n// function set(hash, value) -> promise\nexport let storage = {};\n\n// Save takes a value and serializes and stores it returning the link.\nexport function* save(value) {\n  let buf = encode(value);\n  let hex = sha1(buf);\n  yield storage.set(hex, buf);\n  return new Link(hex);\n}\n\n// Load accepts a link or a string hash as input.\nexport function* load(link) {\n  let hex = typeof link === \"string\" ?\n    link : link.toHex();\n  return decode(yield storage.get(hex));\n}\n\nexport function* exists(link) {\n  let hex = typeof link === \"string\" ?\n    link : link.toHex();\n  return yield storage.has(hex);\n}\n\n// Link has some nice methods in addition to storing the hash buffer.\nexport class Link {\n  constructor(hash) {\n    if (hash.constructor === ArrayBuffer) hash = new Uint8Array(hash);\n    if (hash.constructor === Uint8Array) {\n      this.hash = hash;\n      return;\n    }\n    if (typeof hash === \"string\") {\n      if (!/^[0-9a-f]{40}$/.test(hash)) {\n        throw new TypeError(\"Invalid string, expected hash\");\n      }\n      this.hash = hexToBin(hash);\n      return;\n    }\n    throw new TypeError(\"Invalid hash, expected string or buffer\");\n  }\n  *resolve() {\n    return yield* load(this);\n  }\n  toHex() {\n    return binToHex(this.hash);\n  }\n  toBin() {\n    return this.hash;\n  }\n}\n\n// Look for links in an object\nexport function scan(obj) {\n  let links = [];\n  find(obj);\n  return links;\n\n  function find(obj) {\n\n    if (!obj) return;\n    if (obj instanceof Link) {\n      links.push(obj);\n      return;\n    }\n    if (Array.isArray(obj)) {\n      for (let child of obj) {\n        find(child);\n      }\n      return;\n    }\n    if (obj.constructor === Object) {\n      for (let key in obj) {\n        find(obj[key]);\n      }\n      return;\n    }\n  }\n}\n\n// Register the Link type so we can serialize hashes as a new special type.\n// hash itself is just a 20 byte Uint8Array\nregister(127, Link,\n  (link) => { return link.hash; },\n  (buf) => { return new Link(buf); }\n);\n","\nlet db;\n\nfunction getDB() {\n  if (!db) {\n    db = new Promise(function(resolve, reject) {\n      let openreq = indexedDB.open('keyval-store', 1);\n\n      openreq.onerror = function() {\n        reject(openreq.error);\n      };\n\n      openreq.onupgradeneeded = function() {\n        // First time setup: create an empty object store\n        openreq.result.createObjectStore('keyval');\n      };\n\n      openreq.onsuccess = function() {\n        resolve(openreq.result);\n      };\n    });\n  }\n  return db;\n}\n\nfunction withStore(type, callback) {\n  return getDB().then(function(db) {\n    return new Promise(function(resolve, reject) {\n      let transaction = db.transaction('keyval', type);\n      transaction.oncomplete = function() {\n        resolve();\n      };\n      transaction.onerror = function() {\n        reject(transaction.error);\n      };\n      callback(transaction.objectStore('keyval'));\n    });\n  });\n}\n\nexport let idbKeyval = {\n  get: function(key) {\n    let req;\n    return withStore('readonly', function(store) {\n      req = store.get(key);\n    }).then(function() {\n      return req.result;\n    });\n  },\n  set: function(key, value) {\n    return withStore('readwrite', function(store) {\n      store.put(value, key);\n    });\n  },\n  delete: function(key) {\n    return withStore('readwrite', function(store) {\n      store.delete(key);\n    });\n  },\n  clear: function() {\n    return withStore('readwrite', function(store) {\n      store.clear();\n    });\n  },\n  keys: function() {\n    let keys = [];\n    return withStore('readonly', function(store) {\n      // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\n      // And openKeyCursor isn't supported by Safari.\n      (store.openKeyCursor || store.openCursor).call(store).onsuccess = function() {\n        if (!this.result) return;\n        keys.push(this.result.key);\n        this.result.continue();\n      };\n    }).then(function() {\n      return keys;\n    });\n  }\n};\n","import { storage } from \"./link\";\nimport { idbKeyval } from \"./idb-keyval\";\n\n// Hook up link's storage to use idbKeyval\nstorage.get = idbKeyval.get;\nstorage.set = idbKeyval.set;\nstorage.has = idbKeyval.has;\nstorage.clear = idbKeyval.clear;\n","\n// Usage: async(function* (...args) { yield promise... })(..args) -> Promise\nexport function async(gen) {\n  return function (...args) {\n    return run(gen(...args));\n  };\n}\n// Usage: run(iter) -> Promise\nexport function run(iter) {\n  try { return handle(iter.next()); }\n  catch (ex) { return Promise.reject(ex); }\n  function handle(result){\n    if (result.done) return Promise.resolve(result.value);\n    return Promise.resolve(result.value).then(function (res) {\n      return handle(iter.next(res));\n    }).catch(function (err) {\n      return handle(iter.throw(err));\n    });\n  }\n}\n\nexport function runAll(iters) {\n  return Promise.all(iters.map(run));\n}\n","import \"./libs/cas-idb\"\nimport { storage } from \"./libs/link\"\nimport { run } from \"./libs/async\"\n\nself.onmessage = function(evt) {\n  wsConnect(evt.data.url).then(socket => {\n    return upload(socket, evt.data.hash);\n  })\n    .then(self.postMessage)\n    .catch(self.postMessage);\n};\n\nfunction wsConnect(url) {\n  return new Promise((resolve, reject) => {\n    let socket = new WebSocket(url);\n    socket.onopen = () => resolve(socket);\n    socket.onerror = reject;\n  });\n}\n\nfunction upload(socket, rootHash) {\n  return new Promise((resolve, reject) => {\n    let done = {};\n    let queue = [];\n    socket.send(\"s:\" + rootHash);\n\n    socket.onmessage = evt => {\n      let match = evt.data.match(/^(.):([0-9a-f]{40})$/);\n      if (match) {\n        let command = match[1],\n            hash = match[2];\n        if (command === 'w') {\n          self.postMessage(1);\n          queue.push(hash);\n          run(process());\n          return;\n        }\n        if (command === 'd' && hash === rootHash) {\n          resolve();\n          return;\n        }\n      }\n      console.error(\"Unexpected message from server: \" + evt.data);\n    };\n    socket.onerror = () => {\n      reject(new Error(\"Problem in websocket connection with server\"));\n    }\n\n    let working;\n\n    function* process() {\n      if (working) return;\n      working = true;\n      while (queue.length) {\n        let hash = queue.pop();\n        self.postMessage(-1);\n        if (done[hash]) continue;\n        let bin = yield storage.get(hash);\n        socket.send(bin);\n        done[hash] = true;\n      }\n      working = false;\n    }\n\n  });\n}\n"],"names":[],"mappings":"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"}